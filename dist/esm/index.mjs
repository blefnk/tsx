import{MessageChannel as O,isMainThread as S}from"worker_threads";import{s as F}from"../node-features-18fdd9fd.mjs";import N from"module";import{installSourceMapSupport as w}from"../source-map.mjs";import g from"path";import{fileURLToPath as _,pathToFileURL as U}from"url";import{t as v,a as D}from"../index-dcf242e7.mjs";import{r as L}from"../resolve-ts-path-a8cb04a4.mjs";import{parseTsconfig as A,getTsconfig as J,createFilesMatcher as x,createPathsMatcher as I}from"get-tsconfig";import P from"fs";import"source-map-support";import"esbuild";import"crypto";import"os";const b=()=>{const{port1:t,port2:s}=new O;w(t),process.send&&t.addListener("message",r=>{r.type==="dependency"&&process.send(r)}),t.unref(),N.register("./index.mjs",{parentURL:import.meta.url,data:{port:s},transferList:[s]})},m=new Map;async function $(t){if(m.has(t))return m.get(t);if(!await P.promises.access(t).then(()=>!0,()=>!1)){m.set(t,void 0);return}const r=await P.promises.readFile(t,"utf8");try{const o=JSON.parse(r);return m.set(t,o),o}catch{throw new Error(`Error parsing: ${t}`)}}async function C(t){let s=new URL("package.json",t);for(;!s.pathname.endsWith("/node_modules/package.json");){const r=_(s),o=await $(r);if(o)return o;const n=s;if(s=new URL("../package.json",s),s.pathname===n.pathname)break}}async function W(t){var s;const r=await C(t);return(s=r==null?void 0:r.type)!=null?s:"commonjs"}const T=w(),f=process.env.TSX_TSCONFIG_PATH?{path:g.resolve(process.env.TSX_TSCONFIG_PATH),config:A(process.env.TSX_TSCONFIG_PATH)}:J(),q=f&&x(f),E=f&&I(f),k="file://",h=/\.([cm]?ts|[tj]sx)($|\?)/,G=/\.json(?:$|\?)/,H=t=>{const s=g.extname(t);if(s===".json")return"json";if(s===".mjs"||s===".mts")return"module";if(s===".cjs"||s===".cts")return"commonjs"},X=t=>{const s=H(t);if(s)return s;if(h.test(t))return W(t)},R=/\/(?:$|\?)/;let d,u=process.send?process.send.bind(process):void 0;const K=async t=>{if(!t)throw new Error(`tsx must be loaded with --import instead of --loader
The --loader flag was deprecated in Node v20.6.0`);const{port:s}=t;d=s,u=s.postMessage.bind(s)},Q=({port:t})=>(d=t,u=t.postMessage.bind(t),`
	const require = getBuiltin('module').createRequire("${import.meta.url}");
	require('tsx/source-map').installSourceMapSupport(port);
	if (process.send) {
		port.addListener('message', (message) => {
			if (message.type === 'dependency') {
				process.send(message);
			}
		});
	}
	port.unref(); // Allows process to exit without waiting for port to close
	`),l=async(t,s,r)=>{const o=await t(s,r);return!o.format&&o.url.startsWith(k)&&(o.format=await X(o.url)),o},z=[".js",".json",".ts",".tsx",".jsx"];async function y(t,s,r){const[o,n]=t.split("?");let c;for(const a of z)try{return await l(r,o+a+(n?`?${n}`:""),s)}catch(e){if(c===void 0&&e instanceof Error){const{message:i}=e;e.message=e.message.replace(`${a}'`,"'"),e.stack=e.stack.replace(i,e.message),c=e}}throw c}async function M(t,s,r){const o=R.test(t),n=o?"index":"/index",[c,a]=t.split("?");try{return await y(c+n+(a?`?${a}`:""),s,r)}catch(e){if(!o)try{return await y(t,s,r)}catch{}const i=e,{message:p}=i;throw i.message=i.message.replace(`${n.replace("/",g.sep)}'`,"'"),i.stack=i.stack.replace(p,i.message),i}}const B=/^\.{1,2}\//,j=async function(t,s,r,o){var n;if(R.test(t))return await M(t,s,r);const c=t.startsWith(k)||B.test(t);if(E&&!c&&!((n=s.parentURL)!=null&&n.includes("/node_modules/"))){const a=E(t);for(const e of a)try{return await j(U(e).toString(),s,r)}catch{}}if(h.test(s.parentURL)){const a=L(t);if(a)for(const e of a)try{return await l(r,e,s)}catch(i){const{code:p}=i;if(p!=="ERR_MODULE_NOT_FOUND"&&p!=="ERR_PACKAGE_PATH_NOT_EXPORTED")throw i}}try{return await l(r,t,s)}catch(a){if(a instanceof Error&&!o){const{code:e}=a;if(e==="ERR_UNSUPPORTED_DIR_IMPORT")try{return await M(t,s,r)}catch(i){if(i.code!=="ERR_PACKAGE_IMPORT_NOT_DEFINED")throw i}if(e==="ERR_MODULE_NOT_FOUND")try{return await y(t,s,r)}catch{}}throw a}},V=async function(t,s,r){var o;u&&u({type:"dependency",path:t}),G.test(t)&&(s.importAssertions||(s.importAssertions={}),s.importAssertions.type="json");const n=await r(t,s);if(!n.source)return n;const c=t.startsWith("file://")?_(t):t,a=n.source.toString();if(n.format==="json"||h.test(t)){const e=await v(a,c,{tsconfigRaw:(o=q)==null?void 0:o(c)});return{format:"module",source:T(e,t,d)}}if(n.format==="module"){const e=D(c,a);e&&(n.source=T(e,t,d))}return n};F&&S&&b();export{Q as globalPreload,K as initialize,V as load,j as resolve};
